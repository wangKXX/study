# react

## fiber

fiber是react16之后引入的新的架构，在react内部fiber是整个树上的一个节点，于之前的react版本相比使用
fiber架构之后的虚拟dom树变成了一个链表树，每个树节点上都会存储它对应的位置信息（return 父节点，child 子节点信息 slibing 兄弟节点信息），有了这些溯源信息，才能在上一次开始的地方重新开始，这也是fiber架构可中断的基础，第二点就是整个
render的阶段，react会讲当前展示的虚拟dom树复制一份，然后那复制的这棵树去和新的树做diff，也就是说在commit之前界面上不会有任何影响，界面依然可以正常操作，等到render阶段完成之后，到了commit阶段才是真正的更新dom，同时复制的树也会被销毁，再commit之前的render过程，采用的时间分片的方式来运行的，所以不会阻塞主线程，在遇到优先级较高的任务（处理用户交互）则会中断执行类似于requestIdleCallback的实现，不过react内部并没有直接使用requestIdleCallback。

## 为什么react不直接使用requestIdleCallback

requestIdleCallback是一个相对较新的api,在一些低版本浏览器上会有兼容问题。react使用requestAnimationFrame来代替requestIdleCallback，在低版本浏览器上，requestAnimationFrame兼容性更好。还有一个就是requestIdlecallback的FPS只有20（一秒20帧）要避免用视觉上不卡顿的最低FPS需要30帧，这也是react不直接使用requestIdleCallback的原因之一，requestAnimationFrame的执行频率是和显示器的刷新帧率有关的，比如60hz的显示器，requestAnimationFrame就是16.7毫秒执行一次，而react是希望在一帧里面执行更多的任务,当然直接使用requestAnimationFrame是不能完成任务优先级调度，react还会将一些耗时超过100ms的任务放到setTimeout中执行，同时对一些高优先级的任务采用MessageChannel在其onMessage回调中尽快执行

## react的生命周期

1. constructor
2. componentWillMount
3. render
4. componentDidMount
5. componentWillReceiveProps
6. shouldComponentUpdate // 判断是会否需要更新，返回false则阻止更新
7. getSnapshotBeforeUpdate // 在state或props改变时调用，返回值会传递给componentDidUpdate的第三个参数
8. render
9. componentDidUpdate // 更新完成后
10. componentWillUnmount // 写在之前


