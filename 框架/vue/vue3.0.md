# vue3

## vue3的响应式原理

响应式的本质就是属性和方法的绑定，也就是属性修改调用方法的执行，核心的点在于如何监听属性的变化。
vue3的响应式主要是靠proxy实现的，与vue2响应式最大的差别在于vue3不需要再对对象的的属性进行遍历来
添加getter和setter，大大提升了性能。
proxy可以实现对整个对象操作的监听，其中包括在vue2中需要单独使用$set和$delete操作来进行操作
的添加新属性和删除属性，
当然也可以
直接对数组进行监听。而不是在vue2中通过修改数据的原型方法来实现监听。通过监听对象的属性，
在对象属性被获取的时候触发get来进行依赖收集，也就是
对应源码里面的watcher，当对象属性被修改的时候触发set来进行依赖更新，
更新的逻辑主要通过遍历触发的dep数组, deps中记录了依赖当前属性的所有watcher实例，每一个watcher实例上
都有一个对应的更新方法，通过触发更新方法触发依赖更新。从而实现依赖函数的执行.


## 相比于vue2做了哪些优化
### 源码结构优化
vue3采用了monerepo的代码架构，也就是单仓库多模块的形式。模块划分更清晰，同时代码复用更容易
### 更好的TS支持
vue3 本身就是采用Ts编写，通过内置的TS工具类型来实现更友好的TS支持。
### 更小的体积
### 响应式实现的优化

相较于vue2的Object.defineProperty，vue3的响应式实现采用了Proxy。
proxy可以实现对整个对象的监听，而vue2中需要遍历对象的属性，然后对每个属性进行监听。
对于深层次嵌套对象，vue3采用了在get中获取时代理，也就是需要时再执行代理，
相对于vue2的无脑遍历，性能更优，还有一个就是对于数组的处理，
vue2通过修改数组操作的方式来实现更新的派发，vue3中则不用，可以使用proxy实现。

### 静态提升
在模版编译阶段，vue会对每个节点进行打标，通过将静态节点标记，
将这部分提升到render函数之外，在后续的render中直接复用，不再参与diff
### 函数缓存
在编译阶段对于模版内绑定的函数进行缓存，避免在更新的时候重新绑定

### 更新类型标记
在编译阶段将动态节点的依赖进行区分，在后续render的时候通过标记确定快速的操作，
如更新class,属性更新，子节点更新等

### 树结构打平
在一个区块内部的动态节点会被打平为一个数组，这样后续diff的时候只需要遍历这个打平的机构
。区块指的是一个内部结构稳定的片段，具体来说就是内部不存在破坏结构的操作，比如v-if, 
v-for，对于相对稳定的结构，在编译阶段，vue会将其直接后代里面的动态节点打平，这样可以有效的减少节点数量

### 组合式api
在vue2中通常会采用minxin的方式实现逻辑的复用，在vue3中可以直接使用组合式api也就是hook的方式，将功能模块封装为一个单独的hook，hook之间也可以互相饮用，大大提升了灵活性

### diff算法优化
在vue2中diff采用的是同层双指针遍历，和全量遍历的方式，包括静态节点, 在遍历过程中对乱序列表
需要依赖key值来确保识别和更新元素，在vue3中，采用了基于数组的动态规划算法（最少移动），
来实现最小化的移动和变更节点，同时由于在编译节点做了静态提升，和树结构打平的操作所以在遍历的
效率上有了很大的提升
## vue3的异步更新机制
在连续多次修改组件内的响应式数据之后，vue并不会一次一次的立即执行这些更新，
而是将这些更新放入到一个队列中，然后在通过shceduler模块在下一次事件循环中
批量执行这些更新。scheduler模块通过使用优雅降级的方式来实现批量任务的异步执行
，优先使用promise.then如果不支持则使用MutationObserver
（这里有个技巧，我们知道这个api是用来监听dom变化之后将回调加入到微任务队列的，
所以vue会自己创建一个dom元素，通过修改元素内容来将批量更新函数加到微任务队列），
如果都不支持则使用setTimeout。这里就不得不说下vue中的nextTick的他的本质和异步更新机制是一样的，
也是会把nextTick的回调函数放入下一次事件循环的微任务队列，从而实现获取到组件更新后的状态。
## vue3的事件
vue并没有采取类似react的事件委托处理机制，而是将事件直接绑定在元素上，
这样的好处在于不用在内部去维护一个事件管理的模块，对于开发者来说能减少不必要的心智负担，
同时vue提供的$event对象
可以获取事件的原始对象。react中采用事件委托机制，很大程度上是为了消除平台差异性，
为了能在react-dom,react-native
中居于一样的处理逻辑，所以react采用事件委托和复合事件的策略，当然事件统一管理，
也能带来一些性能和事件维护上的便利，
与vue相比，react在跟节点统一触发，能很大程度上减少浏览器维护的事件数量，只需维护跟节点的交互事件
之后交由react的事件系统去出发对应组件的事件，当然在事件的绑定和解除绑定上也更为便利，
都由react的事件系统来完成
## vue3为什么不需要类似于react的事件分片
主要是vue有对应的依赖收集机制，在首次渲染期间，vue会利用它的响应式系统来收集依赖。这样在后续的更新过程中可以更好的定位更新，既然vue都有了依赖收集来定位更新。而React不存在依赖收集的过程，通过props，setState, context这些变更来主动触发，再由于之前的react没采用fiber架构的时候，每次更新时对于一些深层次大规模组件长时间占用主线程不能及时处理用户交互，导致页面无响应。而vue3通过精确定位组件的更新，再配合异步队列和批处理，从而避免了无法触发用户响应的问题。
## vue3的异步组件加载方案
使用defineAsyncComponent函数，通过返回一个promise来加载组件，可以使用suspense组件来监听组件加载状态，
通过fallback来处理加载中的状态。同时可以在vue-router使用动态import来实现路由的异步加载
## setup 语法糖和选项式api的有哪些区别
在选项式api的setup中通过return返回的属性和方法会被直接暴露在组件实例上，在setup语法糖中不会，需要显式的
使用deffineExpose来暴露

## ref 和 shadowRef

ref和shadowRef的区别在于，ref会创建一个深度响应式对象，而shadowRef则不会，shadowRef会创建一个浅响应式对象，
所谓浅层的响应式对象是指只有对.value的访问是响应式的，改变内部对象的属性并会触发响应式。
对应源码中的差异就在于实例化RefImpl时的初始化参数不同shadowRef则传入true，而ref则传入false。
两者都返回的是RefImpl的实例，只不过shadowRef返回的实例的value属性的值式原始对象，ref返回的是经过toreactive处理后的对象。
toReactive处理过后的对象是一个proxy对象


## ref 和 reactive 的区别

ref 和reactive的区别，ref可是处理任意类型的数据，而reactive只能处理对象，数组等引用类型
对于基本数据类型ref是采用值包裹的方式也就是RefImpl来实现响应式，对于引用数据类型则采用和reactive
一样的方式实现，只不过外层多了一个RefImpl的包裹。ref还可以用来获取组件实例和dom对象，而reactive不能

在使用心智上官方更推荐直接使用ref而非reactive，两者都可以实现响应式数据的同时，ref的表现上更具有一致性
虽然.value的写法让人有点不适应，但是官方提供了unref方法来更方便的获取ref的value值. 在解构中ref和reactive
都会导致基础类型响应式丢失，官方提供toRef和toRefs来关联响应式关系。


## 在vue3中调用api应该放在什么地方

对于组合式api来说可以直接在setup语法糖内直接调用api，因为setup会在所有选项式api之前调用
对于一些有依赖的api调用，也可以放在watchEffect中，watchEffect会会在组件初始化的时候立即调用一次，
之后依赖项发生变化之后也会重新出发
同时你也可以手动去控制watchEffect的调用时机，通过watchEffect的flush参数来控制(post 组件渲染之后，
sync 立即执行，默认 组件渲染之前)。当然也有人在onMounted中调用，这就和在vue2中的mouted中调用是一样的
我们知道mounted生命周期执行的时候是组件已经挂载了（已data中定义的初始值）,当在挂载之后调用则会触发响应式数据
更新渲染，会导致页面数据闪烁。
