# vue项目代码优化

## 为v-for的组件使用同级唯一的key属性

在vue的虚拟dom diff逻辑中会优先对key属性进行比较，如果key相同，则认为两个组件是同一个组件，不会重新渲染。如果不设置key属性的话，则需要进行深度遍历来进行diff，性能会比较低。在vue中我们通常在某些需要强制刷新组件的场景中使用一个refrashKey来通过修改key的值触发重新渲染。

## 使用commputed计算属性代替methods方法

在vue的template中使用methods方法时，每次都会重新执行方法，而computed计算属性只会在依赖的数据发生变化时才会重新计算, 并会对计算的结果进行缓存。

## 使用v-show来代替v-if

v-if在页面上渲染时会移除dom节点，而v-show则会隐藏dom节点，因此v-show性能会比v-if高。

## 不要将v-if和v-for同时使用

这里主要的原因在于v-for的优先级比v-if高，在v-for和v-if同时使用的时候，vue会先创建该节点然后再进行v-if判断，导致不必要的资源浪费。可以采用计算属性或者方法提前对数据进行过滤处理。

## 尽量避免直接操作dom

在vue中尽量里面直接操作dom, 使用vue的响应式系统来更新视图。

## 合理的拆分组件

避免一个组件中结构过于复杂庞大，对组件按照业务属性或者组件功能进行拆分。可以降低项目的复杂度，提高项目的可维护性和可扩展性。

## 事件的销毁

在组件内部监听的一些事件如load，scroll等事件需要在deforeDestroy钩子中手动销毁。不然会引起内存泄漏。

## 组件懒加载

在一些tab场景中使用组件懒加载可以很好的优化页面展示速度

## 路由懒加载

使用路由懒加载可以很大程度上提升mainchunk的体积，从而优化首屏的展示速度

## 对于静态组件使用v-once修饰符

v-once修饰符只会渲染一次，在之后的更新中会跳过该组件，从而提升更新速度。

## 使用keep-alive对组件缓存

有时候在一些列表页面进入到详情页面再返回列表页面又会触发重新渲染，但其实在没有数据编辑的情况下并没有必要对组件完全进行重新渲染. 这种场景下可以对组件实例进行缓存，如果有更新数据需求可以通过activated 生命周期进行更新进行更新。

# vue2项目代码优化

## 非响应式数据不要写在data中或者使用Object.freeze冻结

对于data中我们定义的数据，vue组件在初始化的时候会对其进行响应式转换监听，对于以下静态数据使用Object.freeze冻结，可以提高组件初始化速度。

# vue3项目代码优化

## 使用v-memo
```html

<div v-memo="[valueA, valueB]">
  ...
</div>
v-memo可以有条件的跳过组件或者元素的渲染，传入组件或元素的依赖项如果依赖项保持不变，则组件或元素将不会重新渲染。
```

## 对于静态数据不要使用ref或者reactive

对于静态数据不要使用ref或者reactive，因为ref和reactive都是响应式的，在初始化的时候会进行响应式转换，而静态数据不需要进行响应式转换，因此使用ref或者reactive会增加不必要的性能消耗。

## 对于一些引入数据类型使用shallowRef或者shhallowReactive浅层响应式api

shallowRef和shallowReactive都是浅层响应式，对于一些引用数据类型，比如数组或者对象，使用shallowRef或者shallowReactive可以减少不必要的性能消耗。
我们知道对于使用ref创建的数据是深层次响应的，但是对于大多数引用数据来说，我们并不需要对其子属性的变更进行监听。通过直接更改这个应用对象的引用来触发引用数据类型的响应时间能覆盖大多数场景。
